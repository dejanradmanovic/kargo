use std::io::Write;
use std::path::Path;

use serde::{Deserialize, Serialize};

/// Deterministic lockfile recording exact resolved dependency versions.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Lockfile {
    #[serde(default)]
    pub package: Vec<LockedPackage>,
}

/// A single locked dependency with its resolved coordinates and checksum.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedPackage {
    pub name: String,
    pub group: String,
    pub version: String,
    #[serde(default)]
    pub checksum: Option<String>,
    #[serde(default)]
    pub source: Option<String>,
    #[serde(default)]
    pub scope: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub targets: Vec<String>,
    #[serde(default)]
    pub dependencies: Vec<LockedDependencyRef>,
}

/// A reference to a transitive dependency within the lockfile.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedDependencyRef {
    pub name: String,
    pub group: String,
    pub version: String,
}

impl Lockfile {
    /// Load and parse a `Kargo.lock` file from the given path.
    pub fn from_path(path: &Path) -> miette::Result<Self> {
        let content =
            std::fs::read_to_string(path).map_err(|e| kargo_util::errors::KargoError::Generic {
                message: format!("Failed to read lockfile: {e}"),
            })?;
        toml::from_str(&content).map_err(|e| {
            kargo_util::errors::KargoError::Generic {
                message: format!("Failed to parse lockfile: {e}"),
            }
            .into()
        })
    }

    /// Serialize the lockfile to a pretty-printed TOML string.
    pub fn to_string_pretty(&self) -> miette::Result<String> {
        toml::to_string_pretty(self).map_err(|e| {
            kargo_util::errors::KargoError::Generic {
                message: format!("Failed to serialize lockfile: {e}"),
            }
            .into()
        })
    }

    /// Write the lockfile atomically to disk at the given path.
    ///
    /// Writes to a temporary file in the same directory, then renames it
    /// to the target path. This prevents corruption on crash or power loss.
    pub fn write_to(&self, path: &Path) -> miette::Result<()> {
        let content = self.to_string_pretty()?;
        let header = "# This file is auto-generated by Kargo. Do not edit.\n\n";
        let dir = path.parent().unwrap_or(Path::new("."));
        let mut tmp =
            tempfile::NamedTempFile::new_in(dir).map_err(kargo_util::errors::KargoError::Io)?;
        tmp.write_all(format!("{header}{content}").as_bytes())
            .map_err(kargo_util::errors::KargoError::Io)?;
        tmp.persist(path)
            .map_err(|e| kargo_util::errors::KargoError::Io(e.error))?;
        Ok(())
    }

    /// Build a lockfile from a list of resolved package descriptors.
    ///
    /// Accepts `ResolvedPackageInfo` so kargo-core stays independent of kargo-resolver.
    pub fn generate(packages: Vec<ResolvedPackageInfo>) -> Self {
        let mut pkgs: Vec<LockedPackage> = packages
            .into_iter()
            .map(|p| LockedPackage {
                name: p.artifact,
                group: p.group,
                version: p.version,
                checksum: p.checksum,
                source: p.source,
                scope: p.scope,
                targets: p.targets,
                dependencies: p
                    .dependencies
                    .into_iter()
                    .map(|(g, a, v)| LockedDependencyRef {
                        name: a,
                        group: g,
                        version: v,
                    })
                    .collect(),
            })
            .collect();

        pkgs.sort_by(|a, b| (&a.group, &a.name, &a.version).cmp(&(&b.group, &b.name, &b.version)));

        Self { package: pkgs }
    }

    /// Check whether the lockfile is up-to-date with respect to the declared dependencies.
    ///
    /// `declared` is a list of `(group, artifact, version)` from the manifest.
    pub fn is_up_to_date(&self, declared: &[(String, String, String)]) -> bool {
        for (group, artifact, version) in declared {
            let found = self
                .package
                .iter()
                .any(|p| &p.group == group && &p.name == artifact && &p.version == version);
            if !found {
                return false;
            }
        }
        true
    }

    /// Look up a locked version for a given `group:artifact`.
    pub fn locked_version(&self, group: &str, artifact: &str) -> Option<&str> {
        self.package
            .iter()
            .find(|p| p.group == group && p.name == artifact)
            .map(|p| p.version.as_str())
    }

    /// Number of locked packages.
    pub fn len(&self) -> usize {
        self.package.len()
    }

    pub fn is_empty(&self) -> bool {
        self.package.is_empty()
    }
}

/// A transport struct for lockfile generation, independent of resolver types.
pub struct ResolvedPackageInfo {
    pub group: String,
    pub artifact: String,
    pub version: String,
    pub scope: Option<String>,
    pub source: Option<String>,
    pub checksum: Option<String>,
    pub targets: Vec<String>,
    /// Dependencies as `(group, artifact, version)` tuples.
    pub dependencies: Vec<(String, String, String)>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_sorted_lockfile() {
        let packages = vec![
            ResolvedPackageInfo {
                group: "org.z".to_string(),
                artifact: "z-lib".to_string(),
                version: "1.0".to_string(),
                scope: Some("compile".to_string()),
                source: None,
                checksum: None,
                targets: vec![],
                dependencies: vec![],
            },
            ResolvedPackageInfo {
                group: "org.a".to_string(),
                artifact: "a-lib".to_string(),
                version: "2.0".to_string(),
                scope: Some("compile".to_string()),
                source: None,
                checksum: None,
                targets: vec![],
                dependencies: vec![("org.z".into(), "z-lib".into(), "1.0".into())],
            },
        ];

        let lf = Lockfile::generate(packages);
        assert_eq!(lf.package.len(), 2);
        assert_eq!(lf.package[0].group, "org.a");
        assert_eq!(lf.package[1].group, "org.z");
        assert_eq!(lf.package[0].dependencies.len(), 1);
    }

    #[test]
    fn is_up_to_date_check() {
        let lf = Lockfile {
            package: vec![LockedPackage {
                name: "lib".to_string(),
                group: "org.example".to_string(),
                version: "1.0".to_string(),
                checksum: None,
                source: None,
                scope: None,
                targets: vec![],
                dependencies: vec![],
            }],
        };

        assert!(lf.is_up_to_date(&[("org.example".into(), "lib".into(), "1.0".into())]));
        assert!(!lf.is_up_to_date(&[("org.example".into(), "lib".into(), "2.0".into())]));
    }

    #[test]
    fn locked_version_lookup() {
        let lf = Lockfile {
            package: vec![LockedPackage {
                name: "lib".to_string(),
                group: "org.example".to_string(),
                version: "1.0".to_string(),
                checksum: None,
                source: None,
                scope: None,
                targets: vec![],
                dependencies: vec![],
            }],
        };

        assert_eq!(lf.locked_version("org.example", "lib"), Some("1.0"));
        assert_eq!(lf.locked_version("org.missing", "lib"), None);
    }

    #[test]
    fn round_trip() {
        let lf = Lockfile::generate(vec![ResolvedPackageInfo {
            group: "org.example".to_string(),
            artifact: "lib".to_string(),
            version: "1.0".to_string(),
            scope: Some("compile".to_string()),
            source: Some("https://repo.maven.apache.org/maven2".to_string()),
            checksum: Some("abc123".to_string()),
            targets: vec!["jvm".to_string()],
            dependencies: vec![],
        }]);

        let toml_str = lf.to_string_pretty().unwrap();
        let parsed: Lockfile = toml::from_str(&toml_str).unwrap();
        assert_eq!(parsed.package.len(), 1);
        assert_eq!(parsed.package[0].targets, vec!["jvm"]);
    }
}
