//! BuildConfig.kt code generation from manifest, flavor, and profile data.
//!
//! Generates a Kotlin `object BuildConfig` with compile-time constants
//! derived from the project configuration.

use std::collections::BTreeMap;
use std::path::Path;

use kargo_util::errors::KargoError;

/// Generate a `BuildConfig.kt` file in the given directory.
///
/// `kotlin_package` is the Kotlin package for the generated file
/// (e.g. `"com.example"`). If `None`, no package declaration is emitted.
///
/// `custom_fields` contains user-defined key-value pairs from the
/// `[build-config]` section in `Kargo.toml` and/or flavor build-config.
/// Values support `${env:VAR}` interpolation (resolved before this
/// function is called, during manifest loading).
pub fn generate(
    output_dir: &Path,
    kotlin_package: Option<&str>,
    package_name: &str,
    version: &str,
    profile: &str,
    debug: bool,
    custom_fields: &BTreeMap<String, String>,
) -> miette::Result<std::path::PathBuf> {
    std::fs::create_dir_all(output_dir).map_err(KargoError::Io)?;

    let mut lines = Vec::new();
    lines.push("// Auto-generated by Kargo. Do not edit.".to_string());
    lines.push(String::new());

    if let Some(pkg) = kotlin_package {
        if !pkg.is_empty() {
            lines.push(format!("package {pkg}"));
            lines.push(String::new());
        }
    }

    lines.push("object BuildConfig {".to_string());

    lines.push(format!(
        "    const val BUILD_TYPE: String = \"{}\"",
        escape_kotlin_string(profile)
    ));
    lines.push(format!(
        "    const val VERSION_NAME: String = \"{}\"",
        escape_kotlin_string(version)
    ));
    lines.push(format!("    const val DEBUG: Boolean = {debug}"));
    lines.push(format!(
        "    const val APPLICATION_NAME: String = \"{}\"",
        escape_kotlin_string(package_name)
    ));

    for (key, value) in custom_fields {
        lines.push(format!(
            "    const val {}: String = \"{}\"",
            key,
            escape_kotlin_string(value)
        ));
    }

    lines.push("}".to_string());
    lines.push(String::new());

    let content = lines.join("\n");
    let path = output_dir.join("BuildConfig.kt");
    std::fs::write(&path, &content).map_err(KargoError::Io)?;

    Ok(path)
}

/// Derive a Kotlin package name from a fully-qualified `main-class` value.
///
/// `"com.example.MainKt"` → `Some("com.example")`
/// `"MainKt"` → `None`
pub fn package_from_main_class(main_class: &str) -> Option<String> {
    let last_dot = main_class.rfind('.')?;
    let pkg = &main_class[..last_dot];
    if pkg.is_empty() {
        None
    } else {
        Some(pkg.to_string())
    }
}

fn escape_kotlin_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_buildconfig_with_package() {
        let tmp = tempfile::tempdir().unwrap();
        let mut config = BTreeMap::new();
        config.insert("API_URL".into(), "https://example.com".into());

        let path = generate(
            tmp.path(),
            Some("com.example"),
            "my-app",
            "1.0.0",
            "dev",
            true,
            &config,
        )
        .unwrap();
        assert!(path.exists());

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("package com.example"));
        assert!(content.contains("BUILD_TYPE"));
        assert!(content.contains("VERSION_NAME"));
        assert!(content.contains("DEBUG"));
        assert!(content.contains("API_URL"));
        assert!(content.contains("https://example.com"));
    }

    #[test]
    fn generates_buildconfig_without_package() {
        let tmp = tempfile::tempdir().unwrap();
        let path = generate(
            tmp.path(),
            None,
            "my-app",
            "1.0.0",
            "release",
            false,
            &BTreeMap::new(),
        )
        .unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(!content.contains("package "));
        assert!(content.contains("object BuildConfig"));
    }

    #[test]
    fn package_from_main_class_works() {
        assert_eq!(
            package_from_main_class("com.example.MainKt"),
            Some("com.example".into())
        );
        assert_eq!(
            package_from_main_class("com.example.app.MainKt"),
            Some("com.example.app".into())
        );
        assert_eq!(package_from_main_class("MainKt"), None);
    }
}
